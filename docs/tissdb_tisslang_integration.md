# TissLang as an Integration Middle Layer for TissDB

## 1. Vision: Agent-Driven Data Interaction

While **TissDB** provides a powerful, low-level interface for data storage and retrieval via **TissQL**, and **TissLang** provides a high-level language for orchestrating agentic workflows, a significant opportunity exists in bridging the two. This document outlines a vision and architecture for using TissLang as a "middle layer" to drive complex, intelligent, and goal-oriented interactions with TissDB.

Currently, services interact with TissDB programmatically. By introducing TissLang as an intermediary, we empower an AI agent to perform data-heavy tasks described in a human-readable, declarative script. This moves beyond simple CRUD operations and enables workflows like:

-   **Intelligent Data ETL**: An agent can run a shell script to download data, parse it, transform it based on complex rules (using `PROMPT_AGENT`), and then intelligently insert structured documents into TissDB.
-   **Automated Reporting**: A TissLang script can define a task to query multiple collections, synthesize the results into a summary, and write that summary to a new "reports" collection, all within a single, auditable script.
-   **Adaptive Data Maintenance**: An agent can query for records matching a certain heuristic (e.g., "stale" or "incomplete" data), use its reasoning capabilities to decide on a fix, and then apply updates to the database.

## 2. Proposed Architecture

The core of this integration is a **TissLang Interpreter** that is aware of TissDB. This interpreter acts as a smart middle layer between the high-level TissLang script and the low-level TissDB API.

```
+---------------------+      +-----------------------------+      +-----------------+
|  TissLang Script  |----->|   TissLang Interpreter      |----->|   TissDB API    |
| (e.g., task.tiss) |      |   (Middle Layer)            |      | (TissQL Queries)|
+---------------------+      |                             |      +-----------------+
                           | 1. Parse TissLang script    |
                           | 2. Execute commands         |
                           | 3. IF DB command:           |
                           |    a. Generate TissQL       |
                           |    b. Call TissDB REST API  |
                           | 4. Update agent context     |
                           +-----------------------------+
```

The workflow is as follows:
1.  The TissLang Interpreter receives a script.
2.  It executes the `STEP`s sequentially.
3.  When it encounters standard commands like `RUN` or `WRITE`, it executes them as usual.
4.  When it encounters a new, database-specific command (e.g., `QUERY_DB`), it translates the command's parameters into a valid TissQL query.
5.  It sends this TissQL query to the TissDB `/query` REST endpoint.
6.  The JSON response from TissDB is captured and saved into a variable within the TissLang agent's context (e.g., using the `INTO` keyword).
7.  Subsequent `STEP`s can use this variable, allowing the agent to reason about the query results (e.g., `PROMPT_AGENT "Summarize these results: {{query_results}}"`).

## 3. New TissLang Database Commands

To make TissLang "database-aware," we propose a new set of commands specifically for database interaction. These commands would be first-class citizens in the language, just like `RUN` or `WRITE`.

### `QUERY_DB`
Executes a read-only query against TissDB.

-   **Syntax**: `QUERY_DB "TissQL query string" INTO variable_name`
-   **Action**: The interpreter wraps the query string in the required JSON structure and POSTs it to the TissDB `/_query` endpoint. The result is stored in `variable_name`.

### `INSERT_DOC`
Inserts a new document into a collection.

-   **Syntax**: `INSERT_DOC "collection_name" FROM_VAR variable_name`
-   **Action**: The command retrieves the content of `variable_name` (which could be a JSON string generated by a previous `PROMPT_AGENT` step) and POSTs it to the TissDB `/<collection_name>` endpoint.

### `UPDATE_DOC`
Updates an existing document in a collection.

-   **Syntax**: `UPDATE_DOC "collection_name" DOC_ID "document_id" WITH_VAR variable_name`
-   **Action**: The command retrieves the content from `variable_name` and PUTs it to the TissDB `/<collection_name>/<document_id>` endpoint.

### `DELETE_DOC`
Deletes a document from a collection.

-   **Syntax**: `DELETE_DOC "collection_name" DOC_ID "document_id"`
-   **Action**: The command sends a DELETE request to the TissDB `/<collection_name>/<document_id>` endpoint.

## 4. End-to-End Example: Automated User Summary Report

This example demonstrates a complete workflow where an agent uses TissLang to interact with TissDB to produce a summary report.

Assume TissDB contains two collections:
-   `users`: Documents with user profile data (e.g., `user_id`, `name`, `signup_date`).
-   `user_activity`: Documents logging user actions (e.g., `user_id`, `action_type`, `timestamp`).

**The Goal**: Create a summary for a specific user, including their profile information and a count of their activities, and store it in a new `user_summaries` collection.

**`generate_summary.tiss`**
```tiss
#TISS! Language=TissLang

TASK "Generate and store a summary report for user 'u-123'"

STEP "Query for user profile" {
    QUERY_DB "SELECT * FROM users WHERE user_id = 'u-123'" INTO user_profile
}

STEP "Query for user activity count" {
    QUERY_DB "SELECT COUNT(*) AS activity_count FROM user_activity WHERE user_id = 'u-123'" INTO user_activity
}

STEP "Synthesize the summary using an agent" {
    @persona "data_analyst"
    PROMPT_AGENT "Create a brief JSON summary for the user. Combine the profile data with the activity count. Profile: {{user_profile}}. Activity: {{user_activity}}." INTO json_summary
}

STEP "Store the new summary document" {
    # The 'json_summary' variable now holds a complete JSON string
    # generated by the agent, ready for insertion.
    INSERT_DOC "user_summaries" FROM_VAR json_summary
}

STEP "Verify the insertion" {
    # We can use an assertion to confirm the workflow succeeded.
    # (This assumes LAST_RUN context is updated by DB commands).
    ASSERT LAST_RUN.EXIT_CODE == 201 # HTTP 201 Created
}
```

### How it Works:

1.  **Step 1 & 2**: The interpreter executes two `QUERY_DB` commands, hitting the TissDB API twice and populating the `user_profile` and `user_activity` variables with JSON results.
2.  **Step 3**: The `PROMPT_AGENT` command sends the collected data to the underlying AI model, asking it to generate a new JSON object. The model's response is stored in `json_summary`.
3.  **Step 4**: The `INSERT_DOC` command takes the generated JSON from `json_summary` and sends it to TissDB's `/user_summaries` endpoint, creating a new record.
4.  **Step 5**: The final `ASSERT` confirms that the `INSERT_DOC` operation returned a success code, making the script self-verifying.

## 5. Conclusion

Integrating TissLang and TissDB via a dedicated middle-layer interpreter creates a powerful paradigm for **agent-driven data management**. It abstracts the complexities of direct database interaction into a high-level, auditable script, allowing AI agents to perform sophisticated, multi-step data workflows that are currently difficult to orchestrate. This architecture is a key step toward building more autonomous and capable systems within the Quanta ecosystem.
